<html>
	<head>
	<link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	<script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<title>
		mycharacter.cpp
	</title>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
// Fill out your copyright notice in the Description page of Project Settings.
// JW,JD

#include "ClassProject2.h"
#include "ClassProject2GameMode.h"
#include "GameFramework/InputSettings.h"
#include "public/MyCharacter.h"
#include "public/AbilityList.h"

// Sets default values
AMyCharacter::AMyCharacter()
<span style = "background-color:#dfd">{</span>
 	// Set this character to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
<span style = "background-color:#dfd">	PrimaryActorTick.bCanEverTick = true;
	MaxHealth = 100.f;
	Health = MaxHealth;
	MaxStamina = 100.f;
	Stamina = MaxStamina;
	SprintSpeedModifier = 1.8f;
	DefaultNormalSpeed = this-&gt;GetCharacterMovement()-&gt;MaxWalkSpeed /1.5;
	this-&gt;GetCharacterMovement()-&gt;MaxWalkSpeed = DefaultNormalSpeed;
	exhausted = false;
	CanJumpOverload = false;
	CurrentCastElapse = 0.f;
	MyAffinity = CreateDefaultSubobject&lt;UMyElementalAffinity&gt;(TEXT("Affinity"));</span>
	//debug
<span style = "background-color:#dfd">	MyAffinity-&gt;UpdateElements(5, 0); //Fire
	MyAffinity-&gt;UpdateElements(4, 1); //Earth
	MyAffinity-&gt;UpdateElements(8, 2); //Lightning
	MyAffinity-&gt;UpdateElements(7, 3); //Darkness
	MyAffinity-&gt;UpdateElements(2, 4); //Ice</span>

	//MyAffinity-&gt;RegisterComponent();



<span style = "background-color:#dfd">	GetCapsuleComponent()-&gt;InitCapsuleSize(42.f, 96.0f);</span>
	//Mesh
<span style = "background-color:#dfd">	static ConstructorHelpers::FObjectFinder&lt;USkeletalMesh&gt; mmesh(TEXT("SkeletalMesh'/Game/Mannequin/Character/Mesh/SK_Mannequin.SK_Mannequin'"));
	if (mmesh.Object) </span>
	{
<span style = "background-color:#dfd">		PlayerMesh = GetMesh();
		PlayerMesh-&gt;SetSkeletalMesh(mmesh.Object);
		PlayerMesh-&gt;AddLocalOffset(FVector(0, 0, -98.0f));
		PlayerMesh-&gt;SetRelativeRotation(FRotator(0, -90.0f, 0));</span>
	}

<span style = "background-color:#dfd">	static ConstructorHelpers::FObjectFinder&lt;UAnimBlueprint&gt; MeshAnim(TEXT("AnimBlueprint'/Game/Mannequin/Animations/ThirdPerson_AnimBP.ThirdPerson_AnimBP'"));</span>
	
<span style = "background-color:#dfd">	if (MeshAnim.Object) </span>
	{
<span style = "background-color:#fdd">		SampleBP = MeshAnim.Object;
		GetMesh()-&gt;SetAnimInstanceClass(SampleBP-&gt;GetAnimBlueprintGeneratedClass());</span>
	}

	
	// // set our turn rates for input
	// BaseTurnRate = 45.f;
	// BaseLookUpRate = 45.f;

	// // Don't rotate when the controller rotates. Let that just affect the camera.
<span style = "background-color:#dfd">	bUseControllerRotationPitch = false;
	bUseControllerRotationYaw = false;
	bUseControllerRotationRoll = false;</span>

	// // Configure character movement
<span style = "background-color:#dfd">	GetCharacterMovement()-&gt;bOrientRotationToMovement = true; // Character moves in the direction of input...	
	GetCharacterMovement()-&gt;RotationRate = FRotator(0.0f, 540.0f, 0.0f); // ...at this rotation rate
	GetCharacterMovement()-&gt;JumpZVelocity = 400.f;
	GetCharacterMovement()-&gt;AirControl = 0.2f;</span>

	// Create a camera boom (camera collision)
<span style = "background-color:#dfd">	CameraBoom = CreateDefaultSubobject&lt;USpringArmComponent&gt;(TEXT("CameraBoom"));
	CameraBoom-&gt;SetupAttachment(RootComponent);
	CameraBoom-&gt;TargetArmLength = 350.0f; // The camera follows at this distance behind the character	
	CameraBoom-&gt;bUsePawnControlRotation = true; // Rotate the arm based on the controller</span>

	// Create a follow camera
<span style = "background-color:#dfd">	FollowCamera = CreateDefaultSubobject&lt;UCameraComponent&gt;(TEXT("FollowCamera"));
	FollowCamera-&gt;SetupAttachment(CameraBoom, USpringArmComponent::SocketName); // Attach the camera to the end of the boom and let the boom adjust to match the controller orientation
	FollowCamera-&gt;bUsePawnControlRotation = false; // Camera does not rotate relative to arm</span>

<span style = "background-color:#dfd">	FollowCamera-&gt;SetFieldOfView(110);
	FollowCamera-&gt;AddLocalOffset(FVector(0,0,110));</span>

	//initializing movement effect
	//movementcomponent = CreateDefaultSubobject&lt;UProjectileMovementComponent&gt;(" ");
<span style = "background-color:#dfd">}</span>


// Called when the game starts or when spawned
void AMyCharacter::BeginPlay()
<span style = "background-color:#dfd">{
	Super::BeginPlay();</span>
	//debug
<span style = "background-color:#dfd">	GEngine-&gt;AddOnScreenDebugMessage(-1, 15.0f, FColor::Yellow, FString::SanitizeFloat(MyAffinity-&gt;GetAtkDmgMultiplier()));
	GEngine-&gt;AddOnScreenDebugMessage(-1, 15.0f, FColor::Yellow, FString::FromInt(MyAffinity-&gt;GetAbilityElementalPrefix()));
	GEngine-&gt;AddOnScreenDebugMessage(-1, 15.0f, FColor::Yellow, FString::SanitizeFloat(MyAffinity-&gt;GetCritDmgMultiplier()));
	UWorld* const World = GetWorld();
	FTimerDelegate TimerDele;
	TimerDele.BindUFunction(this, FName("StaminaIncrease"), 1.0f); // multiplier handled in StaminaIncrease
	World-&gt;GetTimerManager().SetTimer(RegenTimer, TimerDele, 0.1f, true, 0.f);
}</span>


// Called every frame, DeltaTime is internal frame ticking time.

void AMyCharacter::Tick( float DeltaTime )
<span style = "background-color:#dfd">{
	Super::Tick( DeltaTime );
	if (exhausted&amp;&amp;Stamina &gt; 20)
		exhausted = false;
	if (Stamina &lt; 0.2)</span>
	{
<span style = "background-color:#dfd">		exhausted = true;
		StopJumping();
		OnSprintFinish();</span>
	}
<span style = "background-color:#dfd">}</span>

// Called to bind functionality to input
void AMyCharacter::SetupPlayerInputComponent(class UInputComponent* MyInputComponent)
<span style = "background-color:#dfd">{</span>
	//Super::SetupPlayerInputComponent(InputComponent);
<span style = "background-color:#dfd">	check(MyInputComponent);</span>
	// Binding inputs to actions
	//we can, for example press WASD to move 
<span style = "background-color:#dfd">	MyInputComponent-&gt;BindAxis("MoveForward", this, &amp;AMyCharacter::MoveForward);
    MyInputComponent-&gt;BindAxis("MoveRight", this, &amp;AMyCharacter::MoveRight);</span>
	//by default we bind mouse to turn camera
<span style = "background-color:#dfd">	MyInputComponent-&gt;BindAxis("Turn", this, &amp;APawn::AddControllerYawInput);
    MyInputComponent-&gt;BindAxis("LookUp", this, &amp;APawn::AddControllerPitchInput);</span>
	//by default we bind spacebar to execute jump
<span style = "background-color:#dfd">	MyInputComponent-&gt;BindAction("Jump", IE_Pressed, this, &amp;AMyCharacter::Jump);
	MyInputComponent-&gt;BindAction("Jump", IE_Released, this, &amp;AMyCharacter::StopJumping);</span>


<span style = "background-color:#dfd">	MyInputComponent-&gt;BindAction("Fire", IE_Pressed, this, &amp;AMyCharacter::OnCast);
	MyInputComponent-&gt;BindAction("Fire", IE_Released, this, &amp;AMyCharacter::CastAbility);</span>

	//MyInputComponent-&gt;BindAction("CastMobilityAbility", IE_Pressed, this, &amp;AMyCharacter::OnCast);
<span style = "background-color:#dfd">	MyInputComponent-&gt;BindAction("CastMobilityAbility", IE_Released, this, &amp;AMyCharacter::CastMobilityAbility);</span>

<span style = "background-color:#dfd">	MyInputComponent-&gt;BindAction("SprintHold", IE_Pressed, this, &amp;AMyCharacter::OnSprint);
	MyInputComponent-&gt;BindAction("SprintHold", IE_Released, this, &amp;AMyCharacter::OnSprintFinish);
}</span>

// MoveFoward handles moving forward and backwards
void AMyCharacter::MoveForward(float Value)
<span style = "background-color:#dfd">{
	if ((Controller != NULL) &amp;&amp; (Value != 0.0f))</span>
	{
		// find out which way is forward
<span style = "background-color:#dfd">		const FRotator Rotation = Controller-&gt;GetControlRotation();
		const FRotator YawRotation(0, Rotation.Yaw, 0);</span>

		// get forward vector
<span style = "background-color:#dfd">		const FVector Direction = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::X);
		AddMovementInput(Direction, Value);</span>
	}
<span style = "background-color:#dfd">}</span>

void AMyCharacter::MoveRight(float Value)
<span style = "background-color:#dfd">{
	if ( (Controller != NULL) &amp;&amp; (Value != 0.0f) )</span>
	{
		// find out which way is right
<span style = "background-color:#dfd">		const FRotator Rotation = Controller-&gt;GetControlRotation();
		const FRotator YawRotation(0, Rotation.Yaw, 0);</span>
	
		// get right vector 
<span style = "background-color:#dfd">		const FVector Direction = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::Y);</span>
		// add movement in that direction
<span style = "background-color:#dfd">		AddMovementInput(Direction, Value);</span>
	}
<span style = "background-color:#dfd">}</span>


bool AMyCharacter::CanJump()
<span style = "background-color:#fdd">{</span>
	// a bug where canjump locked to false?
	// this method is not used, avoided

<span style = "background-color:#fdd">	if (Stamina &gt; 20 &amp;&amp; !CanJumpOverload) </span>
	{
<span style = "background-color:#fdd">		return true;</span>
	}
<span style = "background-color:#fdd">	else
		return false;
}</span>


// void OnJump();
void AMyCharacter::Jump()
<span style = "background-color:#dfd">{
	GEngine-&gt;AddOnScreenDebugMessage(-1, 15.0f, FColor::Yellow, TEXT("Stamina!"));
	GEngine-&gt;AddOnScreenDebugMessage(-1, 15.0f, FColor::Yellow, FString::SanitizeFloat(Stamina));
	if (exhausted || Stamina&lt;20)
		return;
	Super::Jump();
	if (!GetCharacterMovement()-&gt;IsFalling()) {
		StaminaIncrease(-20);</span>
	}
<span style = "background-color:#dfd">}</span>

// void OnJumpFinish();
// void OnSprint();
// void OnSprintFinish();
// virtual void SetIsSprinting(bool IsSprinting);

void AMyCharacter::OnSprint()
<span style = "background-color:#dfd">{
	if (!exhausted)</span>
	{
<span style = "background-color:#dfd">		this-&gt;GetCharacterMovement()-&gt;MaxWalkSpeed = DefaultNormalSpeed*MyAffinity-&gt;GetMovSpeedMultiplier() * SprintSpeedModifier;
		UWorld* const World = GetWorld();
		FTimerDelegate TimerDele;
		TimerDele.BindUFunction(this, FName("StaminaIncrease"), -2.0f);
		World-&gt;GetTimerManager().SetTimer(SprintTimer, TimerDele, 0.1f, true, 0.f);</span>
	}
<span style = "background-color:#dfd">}</span>
void AMyCharacter::OnSprintFinish()
<span style = "background-color:#dfd">{
	UWorld* const World = GetWorld();
	this-&gt;GetCharacterMovement()-&gt;MaxWalkSpeed = DefaultNormalSpeed*MyAffinity-&gt;GetMovSpeedMultiplier();
	World-&gt;GetTimerManager().ClearTimer(SprintTimer);
}</span>

// for network later
// void AMyCharacter::GetLifetimeReplicatedProps(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps) const
// {
//	 Super::GetLifetimeReplicatedProps(OutLifetimeProps);
//	 DOREPLIFETIME_CONDITION(AMyCharacter, IsJumping, COND_SkipOwner);
// }


// //bool TryJump();
// bool IsSprinting() const;

// bool InAir() const;
// bool CanSprint() const;

// float GetSprintSpeedModifier() const;

// // other properties
// float GetMaxHP() const;
float AMyCharacter::GetMaxHP() const 
<span style = "background-color:#fdd">{
	return MaxHealth;
}</span>
// float GetHP() const;
float AMyCharacter::GetHP() const
<span style = "background-color:#dfd">{
	return Health;
}</span>

void AMyCharacter::SetHP(float hp)
<span style = "background-color:#dfd">{
	Health = hp;
	if (GEngine) </span>
	{
<span style = "background-color:#dfd">		GEngine-&gt;AddOnScreenDebugMessage(-1, 15.0f, FColor::Yellow, TEXT("Setting dmg!"));
		GEngine-&gt;AddOnScreenDebugMessage(-1, 15.0f, FColor::Yellow, FString::SanitizeFloat(Health));</span>
	}
<span style = "background-color:#dfd">	if (Health &lt; 0)</span>
	{
<span style = "background-color:#dfd">		Destroy();</span>
	}
<span style = "background-color:#dfd">}</span>

void AMyCharacter::TakeDmg(float x, bool canReduce)
<span style = "background-color:#dfd">{
	if(canReduce)
		SetHP(GetHP() - x/(1.2*MyAffinity-&gt;GetDefenseMultiplier()));
	else 
		SetHP(GetHP() - x);
}</span>

void AMyCharacter::TakingForceFieldDamage(bool yeah)
<span style = "background-color:#dfd">{
	InForceField = yeah;
	UWorld* const World = GetWorld();
	if (InForceField)</span>
	{
<span style = "background-color:#dfd">		FTimerDelegate TimerDel;
		TimerDel.BindUFunction(this, FName("TakeDmg"), 0.5f);
		World-&gt;GetTimerManager().SetTimer(DamageTimer, TimerDel, 0.1f, true, 0.f);</span>
	}
<span style = "background-color:#dfd">	else</span>
	{
<span style = "background-color:#dfd">		World-&gt;GetTimerManager().ClearTimer(DamageTimer);</span>
	}
<span style = "background-color:#dfd">}</span>

// float GetMaxStamina() const;
float AMyCharacter::GetMaxStamina() const
<span style = "background-color:#fdd">{
	return MaxStamina;
}</span>
// float GetStamina() const;
float AMyCharacter::GetStamina() const
<span style = "background-color:#dfd">{
	return Stamina;
}</span>

void AMyCharacter::SetStamina(float sta)
<span style = "background-color:#dfd">{
	if (sta &gt;= MaxStamina) {
		Stamina = MaxStamina-1;</span>
	}
<span style = "background-color:#dfd">	else
	if (sta &lt;= 0) {
		Stamina = 0;
		exhausted = true;</span>
	}
<span style = "background-color:#dfd">	else</span>
	// for debug
<span style = "background-color:#dfd">	if (GEngine &amp;&amp; (int) floor(Stamina) % 10 == 0 &amp;&amp; Stamina&lt;MaxStamina)</span>
	{
<span style = "background-color:#dfd">		GEngine-&gt;AddOnScreenDebugMessage(-1, 15.0f, FColor::Yellow, TEXT("Setting stamina!"));
		GEngine-&gt;AddOnScreenDebugMessage(-1, 15.0f, FColor::Yellow, FString::SanitizeFloat(Stamina));</span>
	} 
<span style = "background-color:#dfd">	Stamina = sta;
}</span>

void AMyCharacter::StaminaIncrease(float x)
<span style = "background-color:#dfd">{</span>
	if (this-&gt;GetCharacterMovement()-&gt;MaxWalkSpeed &gt; DefaultNormalSpeed*MyAffinity-&gt;GetMovSpeedMultiplier() 
<span style = "background-color:#dfd">		&amp;&amp; this-&gt;GetCharacterMovement()-&gt;Velocity.Size()&lt;50) {return;} //holding sprint while not moving will not decrease stamina, but it blocks regen
	if (Stamina &gt; MaxStamina) { SetStamina(MaxStamina-1.5f); } // needs to be reduced more than 1.f (regen is at 1.f, would have bugs)
	else if (Stamina &lt; 0) { SetStamina(0); exhausted = true; }
	else { SetStamina(GetStamina() + x * MyAffinity-&gt;GetStamRegenMultiplier()); }
}</span>

// bool IsAlive() const;
bool AMyCharacter::IsAlive() const
<span style = "background-color:#fdd">{
	return Health &gt; 0;
}</span>

// // basic attack
// bool TryCast();
//  OnCast();
void AMyCharacter::OnCast()
<span style = "background-color:#dfd">{
	CurrentCastSuccess = false;
	FTimerDelegate TimerDel;
	UWorld* const World = GetWorld();
	if (World != NULL)</span>
	{
		//Will be more logics on MaxCastTime if more ability added
<span style = "background-color:#dfd">		TimerDel.BindUFunction(this, FName("CastIncrement"), 1.2f/ MyAffinity-&gt;GetAtkSpeedMultiplier());
		World-&gt;GetTimerManager().SetTimer(CastTimer, TimerDel, 0.01f, true, 0.f);</span>
	}
<span style = "background-color:#dfd">}</span>

void AMyCharacter::CastIncrement(float RequiredTime)
<span style = "background-color:#dfd">{
	if (CurrentCastElapse &gt; RequiredTime) </span>
	{
<span style = "background-color:#dfd">		UWorld* const World = GetWorld();
		CurrentCastSuccess = true;
		World-&gt;GetTimerManager().ClearTimer(CastTimer);
		CurrentCastElapse = 0;</span>
	}
<span style = "background-color:#dfd">	CurrentCastElapse += 0.01f;
}</span>
// need handle later if we would cast something else rather than basic attack - nvm we only have 5 abilities, just write more functions
void AMyCharacter::CastAbility()
<span style = "background-color:#dfd">{
	if (!CurrentCastSuccess) </span>
	{
<span style = "background-color:#dfd">		CurrentCastElapse = 0;
		return; </span>
	}
	// try and fire a projectile
<span style = "background-color:#dfd">	UWorld* const World = GetWorld();
	if (World != NULL)</span>
	{
<span style = "background-color:#dfd">		World-&gt;GetTimerManager().ClearTimer(CastTimer);</span>

<span style = "background-color:#dfd">		const FRotator SpawnRotation = GetControlRotation();
		const FVector SpawnLocation = GetActorLocation() + 150 * FRotationMatrix(SpawnRotation).GetScaledAxis(EAxis::X);</span>

<span style = "background-color:#dfd">		FTransform SpawnTransform(SpawnRotation, SpawnLocation);
		auto Fireballspawn = Cast&lt;AFireball&gt;(UGameplayStatics::BeginDeferredActorSpawnFromClass(this, AFireball::StaticClass(), SpawnTransform));
		if (Fireballspawn != nullptr)</span>
		{
<span style = "background-color:#dfd">			Fireballspawn-&gt;CustomOwner = this;</span>
			//AbilityCasing-&gt;OwnerAffinity-&gt;UpdateAll(MyAffinity-&gt;GetElements()); //not working, maybe just directly access this's affinity

<span style = "background-color:#dfd">			UGameplayStatics::FinishSpawningActor(Fireballspawn, SpawnTransform);</span>
		}
<span style = "background-color:#dfd">		CurrentCastSuccess = false;
		CurrentCastElapse = 0;</span>
	}
<span style = "background-color:#dfd">}</span>

void AMyCharacter::CastMobilityAbility()
<span style = "background-color:#dfd">{
	UWorld* const World = GetWorld();
	if (World != NULL)</span>
	{
		//GetCapsuleComponent()-&gt;SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Overlap);
<span style = "background-color:#dfd">		FRotator SpawnRotation = GetControlRotation();
		const FVector SpawnLocation = GetActorLocation();
		FActorSpawnParameters params2;
		params2.Owner = this;
		params2.Instigator = this;</span>
		//GetCapsuleComponent()-&gt;SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Ignore);
<span style = "background-color:#dfd">		SpawnRotation.Pitch = 0;</span>
		//AMobilityAbility_RushBase* AbilityCasing = World-&gt;SpawnActor&lt;AMobilityAbility_RushBase&gt;(SpawnLocation, SpawnRotation, params2); //hardcoded for now

<span style = "background-color:#dfd">		FTransform SpawnTransform(SpawnRotation,SpawnLocation);
		auto AbilityCasing = Cast&lt;AMobilityAbility_RushBase&gt;(UGameplayStatics::BeginDeferredActorSpawnFromClass(this, AMobilityAbility_RushBase::StaticClass(), SpawnTransform));
		if (AbilityCasing != nullptr)</span>
		{
<span style = "background-color:#dfd">			AbilityCasing-&gt;CustomOwner = this;</span>
			//AbilityCasing-&gt;OwnerAffinity-&gt;UpdateAll(MyAffinity-&gt;GetElements()); //not working, maybe just directly access this's affinity


<span style = "background-color:#dfd">			UGameplayStatics::FinishSpawningActor(AbilityCasing, SpawnTransform);</span>

		}

		//debug
		//I assume that this part is messing with owner passing
<span style = "background-color:#dfd">		AbilityCasing-&gt;AttachToActor(this, FAttachmentTransformRules(EAttachmentRule::SnapToTarget, true));</span>
		//AttachToActor(AbilityCasing, FAttachmentTransformRules(EAttachmentRule::SnapToTarget,true));
		//AbilityCasing-&gt;OwnerAffinity=MyAffinity;
		//DuplicateObject(MyAffinity, AbilityCasing-&gt;OwnerAffinity);


<span style = "background-color:#dfd">		AbilityCasing-&gt;Movement-&gt;UpdatedComponent = this-&gt;GetRootComponent();</span>
		//auto sMovement = AbilityCasing-&gt;Movement;
		//sMovement-&gt;UpdatedComponent = RootComponent;
<span style = "background-color:#dfd">		DisableInput(World-&gt;GetFirstPlayerController());	</span>
		//FTimerHandle local;
<span style = "background-color:#dfd">		FTimerDelegate local2;
		local2.BindUFunction(this, FName("GainController"), AbilityCasing);</span>
		//GetCapsuleComponent()-&gt;SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Block);
<span style = "background-color:#dfd">		World-&gt;GetTimerManager().SetTimer(CastTimer, local2, 1.0f/ MyAffinity-&gt;GetAtkSpeedMultiplier(), false);
		isCharging = true;</span>
	}
<span style = "background-color:#dfd">}</span>

void AMyCharacter::GainController(AActor* effect)//, UProjectileMovementComponent* movementeffecthandle)
<span style = "background-color:#dfd">{
	if (!isCharging)
		return;
	UWorld* const World = GetWorld();
	if (World != NULL)</span>
	{

		
<span style = "background-color:#dfd">		EnableInput(World-&gt;GetFirstPlayerController());</span>
		//if (movementeffecthandle-&gt;IsRooted()) {
			//movementeffecthandle-&gt;RemoveFromRoot();
		//}'
<span style = "background-color:#dfd">		if (Cast&lt;AMobilityAbility_RushBase&gt;(effect))
			if (effect-&gt;IsRooted())</span>
<span style = "background-color:#fdd">				effect-&gt;RemoveFromRoot();</span>
<span style = "background-color:#dfd">			(Cast&lt;AMobilityAbility_RushBase&gt;(effect))-&gt;Deactivate();</span>
		//(Cast&lt;AMobilityAbility_RushBase&gt;(effect))-&gt;Movement-&gt;DestroyComponent();
		//(Cast&lt;AMobilityAbility_RushBase&gt;(effect))-&gt;Collision
		//GetCapsuleComponent()-&gt;SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Block);
	}
<span style = "background-color:#dfd">	isCharging = false;
}</span>

// bool canCast() const;
// float GetCurrentCastElapse() const;
// float GetCurrentCastMax() const;

//Char Progression
//UMyElementalAffinity* AMyCharacter::GetAffinity() {
//	return MyAffinity;
//}


// Can't access affinity directly from other class? have to do this
<span style = "background-color:#fdd">float AMyCharacter::GetAtkSpeedMultiplier() { return MyAffinity-&gt;GetAtkSpeedMultiplier(); }
float AMyCharacter::GetAtkDmgMultiplier() { return MyAffinity-&gt;GetAtkDmgMultiplier(); }
float AMyCharacter::GetMovSpeedMultiplier() { return MyAffinity-&gt;GetMovSpeedMultiplier(); }
float AMyCharacter::GetCritChanceMultiplier() { return MyAffinity-&gt;GetCritChanceMultiplier(); }
float AMyCharacter::GetCritDmgMultiplier() { return MyAffinity-&gt;GetCritDmgMultiplier(); }
float AMyCharacter::GetHPMultiplier() { return MyAffinity-&gt;GetHPMultiplier(); }
float AMyCharacter::GetMomentumResistanceMultiplier() { return MyAffinity-&gt;GetMomentumResistanceMultiplier(); }
float AMyCharacter::GetStamRegenMultiplier() { return MyAffinity-&gt;GetStamRegenMultiplier(); }
float AMyCharacter::GetDefenseMultiplier() { return MyAffinity-&gt;GetDefenseMultiplier(); }</span>

// This should get called after allocating points
void AMyCharacter::UpdateStats()
<span style = "background-color:#dfd">{
	MaxHealth = 100 * MyAffinity-&gt;GetHPMultiplier();
	Health = MaxHealth;
	this-&gt;GetCharacterMovement()-&gt;MaxWalkSpeed = DefaultNormalSpeed*MyAffinity-&gt;GetMovSpeedMultiplier();</span>
	//others not needed yet, those multipliers communicate with abilities directly
<span style = "background-color:#dfd">}</span>


//Misc
//Timing</pre>
	</body>
</html>