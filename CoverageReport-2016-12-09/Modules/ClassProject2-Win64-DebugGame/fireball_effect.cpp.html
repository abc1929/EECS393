<html>
	<head>
	<link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	<script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<title>
		fireball_effect.cpp
	</title>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
// Fill out your copyright notice in the Description page of Project Settings.

#include "ClassProject2.h"
#include "Fireball_Effect.h"
#include "public/MyCharacter.h"
#include "public/Fireball.h"


// Effect object process ability's residual effect on enemy, while ability is destroyed (lighter weight)
<span style = "background-color:#dfd">void AFireball_Effect::BeginPlay() {
	Super::BeginPlay();
	this-&gt;SetLifeSpan(20.f);</span>
	//now think of it the residual effect shall not be affected by the situation
	//where the caster's affinities got weakened during the timespan
	//that is the abilities should snapshot MyAffinity rather than accessing it in realtime
	//but I guess we're not worrying about this currently

	//Affin = CustomOwner-&gt;MyAffinity-&gt;GetProcessedElementAffinities();
	//PrimaryAffin = CustomOwner-&gt;MyAffinity-&gt;PrimaryElementalPrefix;
	//dlratio = (Affin[3]+Affin[2]) &gt; 0 ? Affin[3]/(Affin[3]+Affin[2]) : 0.f;

<span style = "background-color:#dfd">}</span>


//0:burn+def weak; 1:stun+movslow; 2:ministun+drain; 3:drain,def weak 4:atk&amp;movslow+atk weak
//2's drain doesn't behave like leech, while 3 does

//88888

//does the fireball do any residual DoT ?
// just linear ramp down
float AFireball_Effect::dmgCurve(float t) 
<span style = "background-color:#dfd">{ 
	return Affin[0] / 8; </span>
	//also make effect on Target
<span style = "background-color:#dfd">}</span>




//not used currently
<span style = "background-color:#fdd">FVector AFireball_Effect::mmtCurve(float t){ return FVector(0,0,0); }</span>


float AFireball_Effect::stamdrainCurve(float t) 
<span style = "background-color:#fdd">{
	 return 1.f; 
}</span>
 // float


float AFireball_Effect::movSlowCurve(float t)
<span style = "background-color:#fdd">{
	 return 1.f; 
}</span>
 //this is less than 1 : %
// 0.9 to reduce to 90% of the movement speed

bool AFireball_Effect::stunCurve(float t)
<span style = "background-color:#fdd">{
	 return 1.f; 
}</span>
 //this will be a step func

float AFireball_Effect::atkSlowCurve(float t)
<span style = "background-color:#fdd">{
	 return 1.f; 
}</span>
 //this is less than 1 : %


float AFireball_Effect::defWeakenCurve(float t) 
<span style = "background-color:#fdd">{
	 return 1.f; 
}</span>
 //this is less than 1 : %

float AFireball_Effect::atkWeakenCurve(float t) 
<span style = "background-color:#fdd">{
	 return 1.f; 
}</span>
 //this is less than 1 : %




// well pretty sure those functions can easily be congregated into a single function and branch within, but w/e
void AFireball_Effect::applydmg(float start, float end, float d, int n)
<span style = "background-color:#dfd">{
	UWorld* const World = GetWorld();
	World-&gt;GetTimerManager().ClearTimer(dmgCurveTimerHandler);
	FTimerDelegate TimerDel;
	if(start&gt;=end)</span>
	{
<span style = "background-color:#dfd">		World-&gt;GetTimerManager().ClearTimer(dmgCurveTimerHandler);
		return;</span>
	}
	
<span style = "background-color:#dfd">	Target-&gt;TakeDmg(dmgCurve(n*d));</span>

<span style = "background-color:#dfd">	if(GEngine)
		GEngine-&gt;AddOnScreenDebugMessage(-1, 15.0f, FColor::Yellow, TEXT("Doing DoT dmg!"));
	TimerDel.BindUFunction(this, FName("applydmg"), start + d, end, d, n + 1);
	World-&gt;GetTimerManager().SetTimer(dmgCurveTimerHandler, TimerDel, d, false); 	
}</span>

void AFireball_Effect::applystamdrain(float start, float end, float d, int n)
<span style = "background-color:#fdd">{
	UWorld* const World = GetWorld();
	FTimerDelegate TimerDel;
	if(start&gt;=end)</span>
	{
<span style = "background-color:#fdd">		World-&gt;GetTimerManager().ClearTimer(stamdrainCurveTimerHandler);
		return;</span>
	}
<span style = "background-color:#fdd">	TimerDel.BindUFunction(this, FName("applystamdrain"), start+d, end ,d, n+1); //determining d manually
	Target-&gt;StaminaIncrease(-stamdrainCurve(n*d));
	CustomOwner-&gt;StaminaIncrease(dlratio*stamdrainCurve(n*d)); //could be 0</span>

<span style = "background-color:#fdd">	World-&gt;GetTimerManager().ClearTimer(stamdrainCurveTimerHandler);
	World-&gt;GetTimerManager().SetTimer(stamdrainCurveTimerHandler, TimerDel, d, false, -d); 	
}</span>

void AFireball_Effect::applystun(float start, float end, float d, int n)
<span style = "background-color:#fdd">{
	UWorld* const World = GetWorld();
	FTimerDelegate TimerDel;
	if(start&gt;=end)</span>
	{
<span style = "background-color:#fdd">		World-&gt;GetTimerManager().ClearTimer(stunCurveTimerHandler);
		Target-&gt;SetStun(false);
		return;</span>
	}
<span style = "background-color:#fdd">	TimerDel.BindUFunction(this, FName("applystun"), start + d, end ,d, n+1); //determining d manually
	if(stunCurve(n*d)) {Target-&gt;SetStun(true);}</span>

<span style = "background-color:#fdd">	World-&gt;GetTimerManager().ClearTimer(stunCurveTimerHandler);
	World-&gt;GetTimerManager().SetTimer(stunCurveTimerHandler, TimerDel, d, false, -d); 	
}</span>

void AFireball_Effect::applymovslow(float start, float end, float d, int n)
<span style = "background-color:#fdd">{
	UWorld* const World = GetWorld();
	FTimerDelegate TimerDel;
	if(start&gt;=end)</span>
	{
<span style = "background-color:#fdd">		World-&gt;GetTimerManager().ClearTimer(movSlowCurveTimerHandler);
		Target-&gt;SetMovementSpeedDebuffMultiplier(1.f); // reset back to default base speed
		return;</span>
	}
<span style = "background-color:#fdd">	TimerDel.BindUFunction(this, FName("applymovslow"), start + d, end ,d, n+1); //determining d manually</span>
	//Target-&gt;TakeDmg(movSlowCurve(n*d));//add another parameter for MyChar I guess;
<span style = "background-color:#fdd">	Target-&gt;SetMovementSpeedDebuffMultiplier(movSlowCurve(n*d));</span>

<span style = "background-color:#fdd">	World-&gt;GetTimerManager().ClearTimer(movSlowCurveTimerHandler);
	World-&gt;GetTimerManager().SetTimer(movSlowCurveTimerHandler, TimerDel, d, false, -d); 	
}</span>

void AFireball_Effect::applyatkslow(float start, float end, float d, int n)
<span style = "background-color:#fdd">{
	UWorld* const World = GetWorld();
	FTimerDelegate TimerDel;
	if(start&gt;=end)</span>
	{
<span style = "background-color:#fdd">		World-&gt;GetTimerManager().ClearTimer(atkSlowCurveTimerHandler);
		Target-&gt;SetAttackSpeedDebuffMultiplier(1.f);
		return;</span>
	}
<span style = "background-color:#fdd">	TimerDel.BindUFunction(this, FName("applyatkslow"), start + d, end ,d, n+1); //determining d manually
	Target-&gt;SetAttackSpeedDebuffMultiplier(atkSlowCurve(n*d));</span>

<span style = "background-color:#fdd">	World-&gt;GetTimerManager().ClearTimer(atkSlowCurveTimerHandler);
	World-&gt;GetTimerManager().SetTimer(atkSlowCurveTimerHandler, TimerDel, d, false, -d); 	
}</span>

void AFireball_Effect::applydefweak(float start, float end, float d, int n)
<span style = "background-color:#fdd">{
	UWorld* const World = GetWorld();
	FTimerDelegate TimerDel;
	if(start&gt;=end)</span>
	{
<span style = "background-color:#fdd">		World-&gt;GetTimerManager().ClearTimer(defWeakenCurveTimerHandler);
		Target-&gt;SetDefenseDebuffMultiplier(1.f);
		return;</span>
	}
<span style = "background-color:#fdd">	TimerDel.BindUFunction(this, FName("applydefweak"), start + d, end ,d, n+1); //determining d manually
	Target-&gt;SetDefenseDebuffMultiplier(defWeakenCurve(n*d));</span>

<span style = "background-color:#fdd">	World-&gt;GetTimerManager().ClearTimer(defWeakenCurveTimerHandler);
	World-&gt;GetTimerManager().SetTimer(defWeakenCurveTimerHandler, TimerDel, d, false, -d); 	
}</span>

void AFireball_Effect::applyatkweak(float start, float end, float d, int n)
<span style = "background-color:#fdd">{
	UWorld* const World = GetWorld();
	FTimerDelegate TimerDel;
	if(start&gt;=end)</span>
	{
<span style = "background-color:#fdd">		World-&gt;GetTimerManager().ClearTimer(atkWeakenCurveTimerHandler);
		Target-&gt;SetAttackDmgDebuffMultiplier(1.0f);
		return;</span>
	}
<span style = "background-color:#fdd">	TimerDel.BindUFunction(this, FName("applyatkweak"), start + d, end ,d, n+1); //determining d manually
	Target-&gt;SetAttackDmgDebuffMultiplier(atkWeakenCurve(n*d));</span>

<span style = "background-color:#fdd">	World-&gt;GetTimerManager().ClearTimer(atkWeakenCurveTimerHandler);
	World-&gt;GetTimerManager().SetTimer(atkWeakenCurveTimerHandler, TimerDel, d, false, -d); 	
}</span>


//A timer spawns for each effect at its TimeInterval; do increment tracks for each? functionally</pre>
	</body>
</html>