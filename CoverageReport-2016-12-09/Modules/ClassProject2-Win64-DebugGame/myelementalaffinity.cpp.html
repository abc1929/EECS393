<html>
	<head>
	<link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	<script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<title>
		myelementalaffinity.cpp
	</title>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
// Fill out your copyright notice in the Description page of Project Settings.

#include "ClassProject2.h"
#include &lt;algorithm&gt; 
#include &lt;math.h&gt;  
#include "MyElementalAffinity.h"
#include "public/MyCharacter.h"

// character progression class, easier to pass around compared to characters

UMyElementalAffinity::UMyElementalAffinity()
<span style = "background-color:#dfd">{
	Elements.Init(0, 5);
	ProcessedElementAffinities.Init(0, 5);
	CalculateMultipliers();
}</span>


UMyElementalAffinity::UMyElementalAffinity(TArray&lt;float&gt; elements)
<span style = "background-color:#fdd">{
	Elements = elements;
	ProcessedElementAffinities.Init(0, 5);
	CalculateAffinities();
	CalculateMultipliers();
	if (Cast&lt;AMyCharacter&gt;(GetOwner()))
		Cast&lt;AMyCharacter&gt;(GetOwner())-&gt;UpdateStats();
}</span>



void UMyElementalAffinity::UpdateElements(float newamount, int element) //01234 -&gt; FELDI
<span style = "background-color:#dfd">{
	Elements[element] = newamount;
	CalculateAffinities();
	CalculateMultipliers();
	if (Cast&lt;AMyCharacter&gt;(GetOwner()))
		Cast&lt;AMyCharacter&gt;(GetOwner())-&gt;UpdateStats();
	if(GEngine &amp;&amp; Cast&lt;AMyCharacter&gt;(GetOwner())-&gt;IsPlayerControlled())
		GEngine-&gt;AddOnScreenDebugMessage(-1, 15.0f, FColor::Yellow, TEXT("New affinities set"));
}</span>

void UMyElementalAffinity::Update()
<span style = "background-color:#fdd">{
	CalculateAffinities();
	CalculateMultipliers();
	if (Cast&lt;AMyCharacter&gt;(GetOwner()))
		Cast&lt;AMyCharacter&gt;(GetOwner())-&gt;UpdateStats();
}</span>

void UMyElementalAffinity::UpdateAll(TArray&lt;float&gt; ele) //01234 -&gt; FELDI
<span style = "background-color:#fdd">{
	Elements = ele;
	CalculateAffinities();
	CalculateMultipliers();
	if (Cast&lt;AMyCharacter&gt;(GetOwner())) //for cases of non player owner (abilities)
		Cast&lt;AMyCharacter&gt;(GetOwner())-&gt;UpdateStats();
}</span>


float UMyElementalAffinity::PenaltyCurve(float ratio)
<span style = "background-color:#dfd">{
	if (ratio &gt; 0.4)
		return pow(ratio - 0.4, 1.5) / 8.09543f;</span>
<span style = "background-color:#fdd">	else
		return 0.0f;</span>
<span style = "background-color:#dfd">}</span>

//An affinity has a cap of 10 (usually penalized and under 10)
float UMyElementalAffinity::optCurve(float affinity) //scaling curve for max 1.2 multipliers
<span style = "background-color:#dfd">{
	if (affinity &gt; 0)</span>
	{
<span style = "background-color:#dfd">		return 1 + pow(affinity, 1.5) / 158.113883f;</span>
	}
<span style = "background-color:#fdd">	else</span>
<span style = "background-color:#dfd">		return 1.0f;</span>

<span style = "background-color:#dfd">}</span>

float UMyElementalAffinity::opfCurve(float firstAffinity, float secondAffinity, int AffinityCount) //scaling curve for max 1.5 multipliers
<span style = "background-color:#dfd">{
	if (AffinityCount == 2)</span>
	{
<span style = "background-color:#dfd">		return 1 + (0.75*firstAffinity + 0.25*secondAffinity) / 20.f;</span>
	}
<span style = "background-color:#dfd">	else if (AffinityCount == 1)</span>
	{
<span style = "background-color:#dfd">		return 1 + (firstAffinity) / 20.f;</span>
	}
<span style = "background-color:#fdd">	else
		return 1.0f;</span>
<span style = "background-color:#dfd">}</span>

float UMyElementalAffinity::opeCurve(float firstAffinity, float secondAffinity, int AffinityCount) //scaling curve for max 1.8 multipliers
<span style = "background-color:#dfd">{
	if (AffinityCount == 2 &amp;&amp; firstAffinity&gt;0 &amp;&amp; secondAffinity&gt;0)</span>
	{
<span style = "background-color:#dfd">		return 1 + pow((0.75*firstAffinity + 0.25*secondAffinity), 0.8) / 7.8869668f;</span>
	}
<span style = "background-color:#dfd">	else if (AffinityCount == 1 &amp;&amp; firstAffinity&gt;0)</span>
	{
<span style = "background-color:#dfd">		return 1 + pow(firstAffinity, 0.8) / 7.8869668f;</span>
	}
<span style = "background-color:#fdd">	else</span>
<span style = "background-color:#dfd">		return 1.0f;
}</span>

void UMyElementalAffinity::CalculateAffinities()
<span style = "background-color:#dfd">{
	int total = 0;
	int FirstAffinityIndex = 0;
	int SecondAffinityIndex = 0;</span>

<span style = "background-color:#dfd">	if (Elements[0] &gt; Elements[1]) {
		SecondAffinityIndex = 1;
		FirstAffinityIndex = 0;</span>
	}
<span style = "background-color:#dfd">	else {
		SecondAffinityIndex = 0;
		FirstAffinityIndex = 1;</span>
	}
	// we simply need first and second elemental type that the character has the most points allocated
	// sorting is kind of unnecessary, just do this
<span style = "background-color:#dfd">	for (int i = 2; i &lt; 5; i++) {
		if (Elements[i] &gt;= Elements[FirstAffinityIndex]) {
			SecondAffinityIndex = FirstAffinityIndex;
			FirstAffinityIndex = i;</span>
		}
<span style = "background-color:#dfd">		else if (Elements[i] &gt; Elements[SecondAffinityIndex]) {</span>
<span style = "background-color:#fdd">			SecondAffinityIndex = i;</span>
		}
<span style = "background-color:#dfd">	}</span>

<span style = "background-color:#dfd">	PrimaryElementalPrefix = FirstAffinityIndex;</span>

<span style = "background-color:#dfd">	for (int index = 0; index&lt;5; index++) { total += Elements[index]; }//there isn't a native function to sum. 
	TArray&lt;float&gt; weight; //temp stores elements weight , ranging from 0,1
	TArray&lt;float&gt; penalty; //penalty array;
	weight.Init(0, 5);
	penalty.Init(0, 5);
	if (total&gt;0)</span>
	{
		//calculating weight and penalties
<span style = "background-color:#dfd">		for (int index = 0; index&lt;5; index++)</span>
		{
<span style = "background-color:#dfd">			weight[index] = [&amp;, total](auto s)-&gt;auto {return s / total; }(Elements[index]);
		}</span>

<span style = "background-color:#dfd">		for (int index = 0; index&lt;5; index++)</span>
		{
			//elemental supressions, let's say you have 2 ice and 5 fire, it would be the tipping point where fire gets penalized
			//while if you have 6 fire then you won't
<span style = "background-color:#dfd">			if (weight[index % 5] == 0 || weight[(index + 1) % 5] == 0) //compiler is kinda dumb
				continue;
			if (weight[index % 5] / weight[(index + 1) % 5] &gt; 0.4) {
				penalty[(index + 1) % 5] = std::min(PenaltyCurve(weight[index % 5] / weight[(index + 1) % 5]), 0.25f);</span>
			}

<span style = "background-color:#dfd">		}</span>

		//determining prefixes
		//special two element combination need weight combined &gt;0.6, otherwise single element
		//if highest is more than 100% than second, it would be single element
		//if element value is not yet 3, compound type not available.

<span style = "background-color:#dfd">		AbilityElementalPrefix = FirstAffinityIndex;</span>
		//this makes priority FELDI as well in case you have complete equivalent first and second while in the single Elemental state
		// 
<span style = "background-color:#dfd">		if (weight[FirstAffinityIndex] + weight[SecondAffinityIndex] &gt; 0.6 &amp;&amp; weight[FirstAffinityIndex] / weight[SecondAffinityIndex] &lt; 2 &amp;&amp; Elements[FirstAffinityIndex]&gt;3)</span>
			//if (weight[FirstAffinityIndex] / weight[SecondAffinityIndex] &lt; 2)
		{
<span style = "background-color:#dfd">			AbilityElementalPrefix = std::max(10 * FirstAffinityIndex + SecondAffinityIndex, FirstAffinityIndex + 10 * SecondAffinityIndex);</span>
		}

		// I think it is more appropriate to process buff multipliers and stuff otherwhere, not in this class, just keep the data pure
		//ProcessedElementAffinities.Init(0, 5);
<span style = "background-color:#dfd">		for (int index = 0; index &lt; 5; index++)</span>
		{
<span style = "background-color:#dfd">			ProcessedElementAffinities[index] = Elements[index] * (1 - penalty[index]);
		}</span>


	} //this bracket encloses total!=0 info
<span style = "background-color:#dfd">	else</span>
	{
<span style = "background-color:#fdd">		AbilityElementalPrefix = -1;</span>
	}
<span style = "background-color:#dfd">}</span>

void UMyElementalAffinity::CalculateMultipliers()
<span style = "background-color:#dfd">{</span>
	//All are ran because penalities will update
<span style = "background-color:#dfd">	AtkSpeedMultiplier = opfCurve(ProcessedElementAffinities[0], ProcessedElementAffinities[2], 2); //Fire, Lightning &lt;1.5, cast &amp; projectile speed
	AtkDmgMultiplier = opfCurve(ProcessedElementAffinities[3]); //Darkness &lt;1.5
	MovSpeedMultiplier = optCurve(ProcessedElementAffinities[0]);  //Fire &lt;1.2
	CritChanceMultiplier = opeCurve(ProcessedElementAffinities[2]); //Lightning &lt;1.8
	CritDmgMultiplier = opfCurve(ProcessedElementAffinities[2], ProcessedElementAffinities[3], 2); //? Lightning, Darkness 1.5
	HPMultiplier = opeCurve(ProcessedElementAffinities[1]); //Earth &lt;1.8
	MomentumResistanceMultiplier = optCurve(ProcessedElementAffinities[1]); //Earth &lt;1.2
	StamRegenMultiplier = opfCurve(ProcessedElementAffinities[4]); //Ice &lt;1.5
	DefenseMultiplier = opeCurve(ProcessedElementAffinities[1], ProcessedElementAffinities[4], 2); //Earth, Ice &lt;1.8</span>


<span style = "background-color:#dfd">}</span>


TArray&lt;float&gt; UMyElementalAffinity::GetElements() //raw
<span style = "background-color:#fdd">{
	return Elements;
}</span>

TArray&lt;float&gt; UMyElementalAffinity::GetProcessedElementAffinities()
<span style = "background-color:#dfd">{
	return ProcessedElementAffinities;
}</span>

int UMyElementalAffinity::GetAbilityElementalPrefix()
<span style = "background-color:#dfd">{
	return AbilityElementalPrefix;
}</span>

// it's kinda messy how the debuffs are handled. there are some implemented from MyChar side
// some might be here. These are justifiable considering convenience
<span style = "background-color:#dfd">float UMyElementalAffinity::GetAtkSpeedMultiplier() { return AtkSpeedMultiplier; }</span>
float UMyElementalAffinity::GetAtkDmgMultiplier() 
<span style = "background-color:#dfd">{ </span>
	// if (Cast&lt;AMyCharacter&gt;(GetOwner()))
	// 	return GetOwner()-&gt;AttackDmgDebuffMultiplier * AtkDmgMultiplier;
	// else
<span style = "background-color:#dfd">		return AtkDmgMultiplier; 
}</span>

<span style = "background-color:#dfd">float UMyElementalAffinity::GetMovSpeedMultiplier() { return MovSpeedMultiplier; }</span>
<span style = "background-color:#fdd">float UMyElementalAffinity::GetCritChanceMultiplier() { return CritChanceMultiplier; }
float UMyElementalAffinity::GetCritDmgMultiplier() { return CritDmgMultiplier; }</span>
<span style = "background-color:#dfd">float UMyElementalAffinity::GetHPMultiplier() { return HPMultiplier; }
float UMyElementalAffinity::GetMomentumResistanceMultiplier() { return MomentumResistanceMultiplier; }
float UMyElementalAffinity::GetStamRegenMultiplier() { return StamRegenMultiplier; }
float UMyElementalAffinity::GetDefenseMultiplier() { return DefenseMultiplier; }</span>

</pre>
	</body>
</html>