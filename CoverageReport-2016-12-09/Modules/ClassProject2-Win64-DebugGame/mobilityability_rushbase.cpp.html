<html>
	<head>
	<link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	<script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<title>
		mobilityability_rushbase.cpp
	</title>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
// Fill out your copyright notice in the Description page of Project Settings.

#include "ClassProject2.h"
#include "public/Safevolume.h"
#include &lt;algorithm&gt; 
#include &lt;math.h&gt;  
#include "MobilityAbility_RushBase.h"
#include "public/MyCharacter.h"


// Basic mobility ability
AMobilityAbility_RushBase::AMobilityAbility_RushBase(const class FObjectInitializer&amp; ObjectInitializer)
<span style = "background-color:#dfd">{</span>
	
<span style = "background-color:#dfd">	PrimaryActorTick.bCanEverTick = true;</span>

<span style = "background-color:#dfd">	auto Collision = CreateDefaultSubobject&lt;UCapsuleComponent&gt;(TEXT("RootComponent_Collision"));
	Collision-&gt;SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Overlap);</span>



<span style = "background-color:#dfd">	Collision-&gt;InitCapsuleSize(90.f, 110.0f);
	RootComponent = Collision;
	Collision-&gt;SetCollisionProfileName(TEXT("Character Collision Enlarged"));
	Collision-&gt;OnComponentBeginOverlap.AddDynamic(this, &amp;AMobilityAbility_RushBase::OnStartOverlapping);</span>
	//Base rush distance 1000
	//Base dmg
	//Base momentum -&gt; speed
	
<span style = "background-color:#dfd">	Movement = CreateDefaultSubobject&lt;UProjectileMovementComponent&gt;(TEXT("Movement"));
	Movement-&gt;UpdatedComponent = Collision;</span>


<span style = "background-color:#dfd">	Movement-&gt;InitialSpeed = 100.f;
	Movement-&gt;MaxSpeed = 30000.f;
	Movement-&gt;bRotationFollowsVelocity = false;
	Movement-&gt;ProjectileGravityScale = 0.0f;</span>
	
<span style = "background-color:#dfd">}</span>

void AMobilityAbility_RushBase::BeginPlay()
<span style = "background-color:#dfd">{
	Super::BeginPlay();
	this-&gt;SetLifeSpan(3.f);
	if (CustomOwner != nullptr)</span>
	{
<span style = "background-color:#dfd">		Movement-&gt;Velocity = Movement-&gt;Velocity * 10;
		Movement-&gt;Velocity = Movement-&gt;Velocity *std::pow(CustomOwner-&gt;MyAffinity-&gt;GetAtkSpeedMultiplier(), 1.5) * CustomOwner-&gt;MyAffinity-&gt;GetMovSpeedMultiplier(); // 0.5 power from atkspd is actual weight, 1.0 to counter mycharacter side
		BaseVelocity = Movement-&gt;Velocity;
		Movement-&gt;UpdateComponentVelocity();</span>
		//Movement-&gt;MaxSpeed = 1000.f *std::pow(CustomOwner-&gt;MyAffinity-&gt;GetAtkSpeedMultiplier(), 1.5) * CustomOwner-&gt;MyAffinity-&gt;GetMovSpeedMultiplier();
		// debugs, won't appear in game build
<span style = "background-color:#dfd">		if (GEngine) {
			GEngine-&gt;AddOnScreenDebugMessage(-1, 15.0f, FColor::Yellow, TEXT("Rushspeed buffed!, and elemental is " + FString::FromInt(CustomOwner-&gt;MyAffinity-&gt;GetAbilityElementalPrefix())));
			GEngine-&gt;AddOnScreenDebugMessage(-1, 15.0f, FColor::Yellow, FString::SanitizeFloat(Movement-&gt;Velocity.Size()));</span>
		}


<span style = "background-color:#dfd">		switch (CustomOwner-&gt;MyAffinity-&gt;GetAbilityElementalPrefix())</span>
		{
			case 0: {
<span style = "background-color:#fdd">				break;</span>
			}

			case 2:  //lightning based rush, will have slight zigzag movement
			case 21:
			case 20: {
<span style = "background-color:#dfd">				Zigzag(0);</span>
				break;
			}

			default:
				break;
		}
	}
<span style = "background-color:#dfd">	else</span>
	{
<span style = "background-color:#fdd">		Movement-&gt;InitialSpeed = 1000.f;
		Movement-&gt;MaxSpeed = 50000.f;</span>
	}



<span style = "background-color:#dfd">}</span>


AMobilityAbility_RushBase::~AMobilityAbility_RushBase()
<span style = "background-color:#dfd">{</span>
	//auto Owner = Cast&lt;AMyCharacter&gt;(CustomOwner);
	//Owner-&gt;GainController();
<span style = "background-color:#dfd">	if (IsRooted())
		RemoveFromRoot();
}</span>

void AMobilityAbility_RushBase::Zigzag(int count)
<span style = "background-color:#dfd">{
	UWorld* const World = GetWorld();
	Movement-&gt;UpdateComponentVelocity();</span>

<span style = "background-color:#dfd">	World-&gt;GetTimerManager().ClearTimer(ZigzagTimerHandle);
	FTimerDelegate TimerDel;
	if (count == 0) {</span>

<span style = "background-color:#dfd">		Movement-&gt;Velocity = BaseVelocity - 0.25 * FVector(-(BaseVelocity.Y), BaseVelocity.X, 0);
		Zigzag(1);</span>
	}
<span style = "background-color:#dfd">	if (count == 1) {</span>

<span style = "background-color:#dfd">		TimerDel.BindUFunction(this, FName("Zigzag"), 2);
		World-&gt;GetTimerManager().SetTimer(ZigzagTimerHandle, TimerDel, 0.2f, false, -0.2f);
		Movement-&gt;Velocity = BaseVelocity + 0.5*FVector(-(BaseVelocity.Y), BaseVelocity.X, 0);</span>
		
	}

<span style = "background-color:#dfd">	if (count == 2) {
		TimerDel.BindUFunction(this, FName("Zigzag"), 1);
		World-&gt;GetTimerManager().SetTimer(ZigzagTimerHandle, TimerDel, 0.2f, false, -0.2f);
		Movement-&gt;Velocity = BaseVelocity + 0.5*FVector(BaseVelocity.Y, -(BaseVelocity.X), 0);</span>
		//Movement-&gt;Velocity = Movement-&gt;Velocity + Movement-&gt;Velocity.RightVector * 2500;		
	}
<span style = "background-color:#dfd">}</span>


void AMobilityAbility_RushBase::OnStartOverlapping(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult&amp; SweepResult)
<span style = "background-color:#dfd">{
	if (CustomOwner != OtherActor &amp;&amp; !OtherActor-&gt;IsA(ASafevolume::StaticClass()) &amp;&amp; OtherActor-&gt;IsA(AMyCharacter::StaticClass())) //hit something valid</span>
	{	
<span style = "background-color:#dfd">		if (GEngine)
			GEngine-&gt;AddOnScreenDebugMessage(-1, 15.0f, FColor::Yellow, FString::SanitizeFloat(CustomOwner-&gt;MyAffinity-&gt;GetHPMultiplier()));
		Deactivate();</span>
		//Movement-&gt;DestroyComponent();
<span style = "background-color:#dfd">		UWorld* const World = GetWorld();
		Cast&lt;AMyCharacter&gt;(CustomOwner)-&gt;isCharging = false;
		Cast&lt;AMyCharacter&gt;(CustomOwner)-&gt;EnableInput(World-&gt;GetFirstPlayerController());
		if (AMyCharacter* targethit = Cast&lt;AMyCharacter&gt;(OtherActor)) {
			if (targethit != CustomOwner)</span>
			{
<span style = "background-color:#dfd">				Knockbackstep = this-&gt;BaseVelocity / 500;</span>
				
<span style = "background-color:#dfd">				targethit-&gt;TakeDmg(</span>
					Cast&lt;AMyCharacter&gt;(CustomOwner)-&gt;AttackDmgDebuffMultiplier 
					* 15.0f 
					* Cast&lt;AMyCharacter&gt;(CustomOwner)-&gt;MyAffinity-&gt;GetAtkDmgMultiplier()
				);
<span style = "background-color:#dfd">				FTimerDelegate TimerDel;
				TimerDel.BindUFunction(this, FName("Knockback"), targethit);
				World-&gt;GetTimerManager().SetTimer(KnockbackTimerHandle, TimerDel, 0.01f, true, 0.f);</span>
			}
<span style = "background-color:#dfd">			this-&gt;SetActorHiddenInGame(true);
			this-&gt;SetActorEnableCollision(false);</span>
		}
	}
<span style = "background-color:#dfd">}</span>

void AMobilityAbility_RushBase::Knockback(AMyCharacter* InflictedTarget)
<span style = "background-color:#dfd">{</span>
	//possible to do AOE this way as well, but right now we're just doing single target
<span style = "background-color:#dfd">	InflictedTarget-&gt;AddActorWorldOffset(2.5 * Knockbackstep / InflictedTarget-&gt;MyAffinity-&gt;GetMomentumResistanceMultiplier()); //maybe even square the multiplier if gameplay wise knockback resistance too underpowered</span>

<span style = "background-color:#dfd">	if (increments &gt;= 50)</span>
	{

<span style = "background-color:#dfd">		UWorld* const World = GetWorld();
		World-&gt;GetTimerManager().ClearTimer(KnockbackTimerHandle);</span>

<span style = "background-color:#dfd">		Destroy();</span>
	}
<span style = "background-color:#dfd">	increments++;
}</span>

// cleaning up ability, ready to destroy after all effects are processed on enemy
void AMobilityAbility_RushBase::Deactivate()
<span style = "background-color:#dfd">{
	Movement-&gt;DestroyComponent();
	if (false == CustomOwner-&gt;ClickedUIButtons(1) || CustomOwner-&gt;ClickedUIButtons(2) || CustomOwner-&gt;ClickedUIButtons(3))
		CustomOwner-&gt;GameInputDisabled = false;
	this-&gt;SetActorEnableCollision(false);
}</span></pre>
	</body>
</html>