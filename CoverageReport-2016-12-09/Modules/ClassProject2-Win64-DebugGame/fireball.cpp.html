<html>
	<head>
	<link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	<script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<title>
		fireball.cpp
	</title>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
// Fill out your copyright notice in the Description page of Project Settings.

#include "ClassProject2.h"
#include "public/Fireball.h"
#include "public/MyCharacter.h"
#include "Fireball_Effect.h"


// Even though it is called Fireball, this class is for all basic ranged attack.
AFireball::AFireball()
<span style = "background-color:#dfd">{</span>
 	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
<span style = "background-color:#dfd">	PrimaryActorTick.bCanEverTick = true;</span>
	// Setup collision sphere and static mesh
<span style = "background-color:#dfd">	Collision = CreateDefaultSubobject&lt;USphereComponent&gt;(TEXT("RootComponent"));
	RootComponent = Collision;
	Collision-&gt;InitSphereRadius(28.0f);
	Collision-&gt;SetCollisionProfileName(TEXT("Projectile"));
	Collision-&gt;BodyInstance.SetCollisionProfileName("Projectile");
	FireballMesh = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(TEXT("ballmesh"));
	FireballMesh-&gt;SetupAttachment(RootComponent);
	Firetrail = CreateDefaultSubobject&lt;UParticleSystemComponent&gt;(TEXT("FireTrail"));
	Firetrail-&gt;SetupAttachment(FireballMesh);</span>
	
<span style = "background-color:#dfd">	Firetrail-&gt;bAutoActivate = true;
	Movement = CreateDefaultSubobject&lt;UProjectileMovementComponent&gt;(TEXT("Movement"));
	Movement-&gt;UpdatedComponent = Collision;
	Movement-&gt;InitialSpeed = 100.f; //* Cast&lt;AMyCharacter&gt;(GetOwner())-&gt;MyAffinity-&gt;GetAtkSpeedMultiplier();
	Movement-&gt;MaxSpeed = 50000.f; //* Cast&lt;AMyCharacter&gt;(GetOwner())-&gt;MyAffinity-&gt;GetAtkSpeedMultiplier();
	GetAssets();</span>

	//AfterEffect = CreateDefaultSubobject&lt;AFireball_Effect&gt;(TEXT("Affinity"));v

	//Knockback variables
<span style = "background-color:#dfd">	increments = 0;</span>

<span style = "background-color:#dfd">}</span>

// Called when the game starts or when spawned
void AFireball::BeginPlay()
<span style = "background-color:#dfd">{
	Super::BeginPlay();
	this-&gt;SetLifeSpan(20.f);
	CreateMesh(CustomOwner-&gt;MyAffinity-&gt;PrimaryElementalPrefix);</span>


<span style = "background-color:#dfd">	Movement-&gt;Velocity=Movement-&gt;Velocity * Cast&lt;AMyCharacter&gt;(CustomOwner)-&gt;MyAffinity-&gt;GetAtkSpeedMultiplier();
	Movement-&gt;UpdateComponentVelocity();</span>
	
<span style = "background-color:#dfd">}</span>

// Called every frame
void AFireball::Tick( float DeltaTime )
<span style = "background-color:#dfd">{
	Super::Tick( DeltaTime );
	if (this-&gt;GetActorLocation().Size() &gt; 10000) {
		this-&gt;Destroy();</span>
		// prevent projectile shooting to the sky sticking too long, maybe it is too heavy compared to using a skybox?
	}

	//lightning bolt animation logic
<span style = "background-color:#dfd">	if (CustomOwner-&gt;MyAffinity-&gt;PrimaryElementalPrefix==2) {
		Firetrail-&gt;SetBeamTargetPoint(0, FireballMesh-&gt;GetComponentLocation(), 0);
		Firetrail-&gt;SetBeamSourcePoint(0, CustomOwner-&gt;GetActorLocation() + 50 * FRotationMatrix(CustomOwner-&gt;GetActorRotation()).GetScaledAxis(EAxis::X), 0);</span>
	}
<span style = "background-color:#dfd">}</span>

<span style = "background-color:#dfd">void AFireball::GetAssets() {
	static ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt; t_mmesh(TEXT("StaticMesh'/Game/StarterContent/Props/MaterialSphere.MaterialSphere'"));
	if (t_mmesh.Object) { mmesh = t_mmesh.Object; }
	static ConstructorHelpers::FObjectFinder&lt;UParticleSystem&gt; t_ParticleAsset_sparks(TEXT("ParticleSystem'/Game/ThirdPersonCPP/Blueprints/pLightningBeam.pLightningBeam'"));
	if (t_ParticleAsset_sparks.Object) { ParticleAsset_sparks = t_ParticleAsset_sparks.Object; }
	static ConstructorHelpers::FObjectFinder&lt;UMaterial&gt; t_grime(TEXT("Material'/Game/StarterContent/Materials/M_Concrete_Grime.M_Concrete_Grime'"));
	if (t_grime.Object) { grime = t_grime.Object; }
	static ConstructorHelpers::FObjectFinder&lt;UParticleSystem&gt; t_ParticleAsset_fire(TEXT("ParticleSystem'/Game/StarterContent/Particles/P_Fire.P_Fire'"));
	if (t_ParticleAsset_fire.Object) { ParticleAsset_fire = t_ParticleAsset_fire.Object; }
}</span>


//This determines basic visuals
void AFireball::CreateMesh(int PrimaryElementalPrefix)
<span style = "background-color:#dfd">{
	switch (PrimaryElementalPrefix)</span>
	{
		// fire/default case Fireball - slow projectile
		case 0:
		{
<span style = "background-color:#dfd">			if (mmesh)</span>
			{
<span style = "background-color:#dfd">				FireballMesh-&gt;SetStaticMesh(mmesh);
				FireballMesh-&gt;SetWorldScale3D(FVector(0.5f));
				FireballMesh-&gt;SetRelativeLocation(FVector(0.0f, 0.0f, 0.f));</span>
		
<span style = "background-color:#dfd">				if (grime)
					FireballMesh-&gt;SetMaterial(0, grime);</span>
			}

			//Fire
<span style = "background-color:#dfd">			Firetrail-&gt;SetRelativeLocation(FVector(0.0f, 0.0f, 35.0f));
			if (ParticleAsset_fire)</span>
			{
<span style = "background-color:#dfd">				Firetrail-&gt;SetTemplate(ParticleAsset_fire);
				Firetrail-&gt;SetWorldScale3D(FVector(1.2f));</span>
			}

			//Movement
	
			// speed:800 = 100*8
<span style = "background-color:#dfd">			Movement-&gt;Velocity = Movement-&gt;Velocity * 8;</span>
		
<span style = "background-color:#dfd">			Movement-&gt;bRotationFollowsVelocity = false;
			Movement-&gt;ProjectileGravityScale = 0.01;</span>

			//TArray&lt;TSharedPtr&lt;FName&gt;&gt; CollisionList;
			//UCollisionProfile::Get()-&gt;GetProfileNames(CollisionList);
<span style = "background-color:#dfd">			Collision-&gt;SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Block);
			Collision-&gt;SetNotifyRigidBodyCollision(true);
			Collision-&gt;OnComponentHit.AddDynamic(this, &amp;AFireball::OnHit);</span>

<span style = "background-color:#dfd">			break;</span>
		}
		
		// Earth, I guess I'll call it Chasm - slow projectile travels on the ground rather than mid air
		case 1:
		{

<span style = "background-color:#fdd">			CreateMesh(0);
			break;</span>
		}

		// Lightning bolt - ultra fast projectile
		case 2:
		{
<span style = "background-color:#dfd">			if (mmesh)</span>
			{
<span style = "background-color:#dfd">				FireballMesh-&gt;SetStaticMesh(mmesh);
				FireballMesh-&gt;SetWorldScale3D(FVector(0.1f));
				FireballMesh-&gt;SetRelativeLocation(FVector(0.0f, 0.0f, 0.f));
				if (grime)
					FireballMesh-&gt;SetMaterial(0, grime);</span>
			}

			//This gonna be sparks
			
<span style = "background-color:#dfd">			Firetrail-&gt;SetRelativeLocation(FVector(0.0f, 0.0f, 35.0f));
			if (ParticleAsset_sparks)</span>
			{

<span style = "background-color:#dfd">				Firetrail-&gt;SetTemplate(ParticleAsset_sparks);</span>

<span style = "background-color:#dfd">				Firetrail-&gt;SetWorldScale3D(FVector(1.5f));</span>
			}

			//Movement
<span style = "background-color:#dfd">			Movement-&gt;Velocity = Movement-&gt;Velocity * 32;
			Movement-&gt;bRotationFollowsVelocity = false;
			Movement-&gt;ProjectileGravityScale = 0.01;</span>

			//TArray&lt;TSharedPtr&lt;FName&gt;&gt; CollisionList;
			//UCollisionProfile::Get()-&gt;GetProfileNames(CollisionList);
<span style = "background-color:#dfd">			Collision-&gt;SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Block);
			Collision-&gt;SetNotifyRigidBodyCollision(true);
			Collision-&gt;OnComponentHit.AddDynamic(this, &amp;AFireball::OnHit);</span>


<span style = "background-color:#dfd">			break;</span>
		}

		// rest not implemented

		// Agony - a instant reach basic attack. afflict dmg and knock back after some time period
		case 3:
		{
<span style = "background-color:#fdd">			CreateMesh(0);
			break;</span>
		}

		// Frost Lance - faster than Fireball
		case 4:
		{
<span style = "background-color:#fdd">			CreateMesh(0);</span>
			break;
		}


		default:
			break;
	}


	
<span style = "background-color:#dfd">}</span>


void AFireball::OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult&amp; Hit) 
<span style = "background-color:#dfd">{
	switch (CustomOwner-&gt;MyAffinity-&gt;PrimaryElementalPrefix)</span>
	{
<span style = "background-color:#dfd">		case 0: {Knockbackstep = this-&gt;GetVelocity() / 300; break; } //Fire</span>
<span style = "background-color:#fdd">		case 1: {Knockbackstep = FVector(0, 0, 0);  break; } //Earth</span>
<span style = "background-color:#dfd">		case 2: {Knockbackstep = this-&gt;GetVelocity() / 1200; break; } //Lightning</span>
<span style = "background-color:#fdd">		case 3: {Knockbackstep = FVector(0,0,0); break; } //Death
		case 4: {Knockbackstep = this-&gt;GetVelocity() / 450;  break; } //Ice</span>
		default:
			break;
	}
	
<span style = "background-color:#dfd">	if (AMyCharacter* targethit = Cast&lt;AMyCharacter&gt;(OtherActor)) {</span>

<span style = "background-color:#dfd">		if (targethit == CustomOwner)</span>
		{
<span style = "background-color:#dfd">			Destroy();</span>
		}
<span style = "background-color:#dfd">		else </span>
		//more complex damage inflicting mechanisms can be implemented
		{ 
<span style = "background-color:#dfd">			targethit-&gt;TakeDmg(</span>
				Cast&lt;AMyCharacter&gt;(CustomOwner)-&gt;AttackDmgDebuffMultiplier 
				* 15.0f 
				* Cast&lt;AMyCharacter&gt;(CustomOwner)-&gt;MyAffinity-&gt;GetAtkDmgMultiplier()
			);
<span style = "background-color:#dfd">			UWorld* const World = GetWorld();
			FTimerDelegate TimerDel;
			TimerDel.BindUFunction(this, FName("Knockback"), targethit);
			World-&gt;GetTimerManager().SetTimer(KnockbackTimerHandle, TimerDel, 0.01f, true, 0.f);</span>


<span style = "background-color:#dfd">			FTransform SpawnTransform;
			auto AfterEffect = Cast&lt;AFireball_Effect&gt;(UGameplayStatics::BeginDeferredActorSpawnFromClass(this, AFireball_Effect::StaticClass(), SpawnTransform));
			if (AfterEffect != nullptr)</span>
			{
<span style = "background-color:#dfd">				AfterEffect-&gt;Target = targethit;
				AfterEffect-&gt;CustomOwner = CustomOwner;
				AfterEffect-&gt;_initialize();
				AfterEffect-&gt;applydmg(0, 2, 0.2, 0);
				UGameplayStatics::FinishSpawningActor(AfterEffect, SpawnTransform);</span>

			}



		}
		// deactivating fireball immediately, it only hits once
<span style = "background-color:#dfd">		this-&gt;SetActorHiddenInGame(true);
		this-&gt;SetActorEnableCollision(false);</span>
		
	} 
<span style = "background-color:#dfd">	else </span>
	{ //should spawn a explosion effect to be implemented
<span style = "background-color:#dfd">		Destroy(); </span>
	}
	
<span style = "background-color:#dfd">}</span>

void AFireball::Knockback(AMyCharacter* InflictedTarget)
<span style = "background-color:#dfd">{</span>
	//possible to do AOE this way as well, but right now we're just doing single target
<span style = "background-color:#dfd">	InflictedTarget-&gt;AddActorWorldOffset(2 * Knockbackstep / InflictedTarget-&gt;MyAffinity-&gt;GetMomentumResistanceMultiplier());</span>

<span style = "background-color:#dfd">	if (increments &gt;= 50)</span>
	{
<span style = "background-color:#dfd">		UWorld* const World = GetWorld();
		World-&gt;GetTimerManager().ClearTimer(KnockbackTimerHandle);
		Collision-&gt;SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Ignore);
		Destroy();</span>
	}
<span style = "background-color:#dfd">	increments++;
}</span></pre>
	</body>
</html>